#!/bin/env raku
enum Seat(empty => :2<10>, occupied => 1, floor => 0);
sub MAIN(Bool :$p2=?0, Bool :$p1=!$p2, Bool :$v) {
    my @seats = lines».comb.».Array.deepmap({ when 'L' { empty    }
                                              when '#' { occupied }
                                              when '.' { floor    }});
    when $p1 { say run-simulation(@seats).tail.deepmap({ $_ == occupied || |Empty }).sum } 

}

sub count-adjacent-seats(@seats) {
    $_ = @seats.deepmap(* +& :2<01>);
    [Z«+»] (.&shift(:left), .&shift(:right), .&shift(:up), .&shift(:down), .&shift(:up, :left),
            .&shift(:up, :right), .&shift(:down, :left), .&shift(:down, :right));
}

sub shift($_, :left(:$l)=0, :right(:$r)=0, :$up=0, :down(:$d)=0) {
    sub term:<⌀> is pure { 0 xx .head.elems }
    [ (⌀ if $d), |.map({[(0 if $r), |@^row[0+$l..^*-$r], (0 if $l)]})[0+$up..^*-$d], (⌀ if $up) ]
}

sub run-simulation(@seats) { gather { loop {
    my @adjacent-seats = @seats.&count-adjacent-seats;
    my @new-seats = (@seats Z«,» @adjacent-seats).duckmap(-> ($_, $adj) {
                        when floor       { floor }
                        when occupied    { $adj ≥  4 ?? empty    !! occupied }
                        when empty       { $adj == 0 ?? occupied !! empty    }});
    take @new-seats;
    @new-seats !eqv @seats ?? (@seats = @new-seats) !! last; 
}}}


DOC CHECK { use Test;
    my $in = q:to/§/;
        L.LL.LL.LL
        LLLLLLL.LL
        L.L.L..L..
        LLLL.LL.LL
        L.LL.LL.LL
        L.LLLLL.LL
        ..L.L.....
        LLLLLLLLLL
        L.LLLLLL.L
        L.LLLLL.LL
        §

    my @in = $in.lines».comb.».Array;
    my @seats = @in.deepmap({ when 'L' { empty  }
                              when '#' { occupied  }
                              when '.' { floor }});
    my $row-len = $in.lines.head.chars;
    my uint @occupied-seat-rows = $in.lines».trans(<. # L> => <0 1 0>).map({:2($_)});
    my uint @empty-seat-rows    = $in.lines».trans(<. # L> => <0 0 1>).map({:2($_)});

subtest {
    my @steps = run-simulation(@seats); 
    @steps[0].&render.&is(q:to/§/, "After 1 round");
        #.##.##.##
        #######.##
        #.#.#..#..
        ####.##.##
        #.##.##.##
        #.#####.##
        ..#.#.....
        ##########
        #.######.#
        #.#####.##
        §

    @steps[1].&render.&is(q:to/§/, "After 2 rounds");
        #.LL.L#.##
        #LLLLLL.L#
        L.L.L..L..
        #LLL.LL.L#
        #.LL.LL.LL
        #.LLLL#.##
        ..L.L.....
        #LLLLLLLL#
        #.LLLLLL.L
        #.#LLLL.##
        §

    @steps[2].&render.&is(q:to/§/, "After 3 rounds");
        #.##.L#.##
        #L###LL.L#
        L.#.#..#..
        #L##.##.L#
        #.##.LL.LL
        #.###L#.##
        ..#.#.....
        #L######L#
        #.LL###L.L
        #.#L###.##
        §
    
    @steps[3].&render.&is(q:to/§/, "After 4 rounds");
        #.#L.L#.##
        #LLL#LL.L#
        L.L.L..#..
        #LLL.##.L#
        #.LL.LL.LL
        #.LL#L#.##
        ..L.L.....
        #L#LLLL#L#
        #.LLLLLL.L
        #.#L#L#.##
        §

    @steps[4].&render.&is(q:to/§/, "After 5 rounds"); 
        #.#L.L#.##
        #LLL#LL.L#
        L.#.L..#..
        #L##.##.L#
        #.#L.LL.LL
        #.#L#L#.##
        ..L.L.....
        #L#L##L#L#
        #.LLLLLL.L
        #.#L#L#.##
        §
    
    @steps[5].&render.&is(q:to/§/, "After 6 rounds");
        #.#L.L#.##
        #LLL#LL.L#
        L.#.L..#..
        #L##.##.L#
        #.#L.LL.LL
        #.#L#L#.##
        ..L.L.....
        #L#L##L#L#
        #.LLLLLL.L
        #.#L#L#.##
        §

    @steps.tail.deepmap({ $_ == occupied ?? 1 !! |Empty }).sum.&is(37, 'total occupied seats');
}, 'part 1';

subtest {
    my $case1 = q:to/§/;
        .......#.
        ...#.....
        .#.......
        .........
        ..#L....#
        ....#....
        .........
        #........
        ...#.....
        §
    my @c1 = $case1.lines».comb.».Array.deepmap({ when 'L' { empty    }
                                              when '#' { occupied }
                                              when '.' { floor    }});
    
        my @see-to-left = @c1.map({[report-visable($_)]});
        my @see-to-right = @c1.map({[.reverse.&report-visable.reverse]});
        my @see-to-top = ([Z]  ([Z] @c1).map({[report-visable($_)]}));
        my @see-to-bot = ([Z]  ([Z] @c1).map({[.reverse.&report-visable.reverse]}));

        my @see:<↑\←> = ([Z] ([Z] @c1.&mkdiagonal(:anti))
                                                  .map({.reverse.&report-visable.reverse}))
                                                  .deepmap({.defined ?? $_ !! |()});
        my @see:<↓\→> = ([Z] ([Z] @c1.&mkdiagonal(:anti)) #* TODO - use :anti
                                                  .map({report-visable($_)}))
                                                  .deepmap({.defined ?? $_ !! |()});
        my @see:<↑/→> = ([Z] ([Z] @c1.&mkdiagonal).map({report-visable($_)}))
                                                  .deepmap({.defined ?? $_ !! |()});
        my @see:<↓/←> = ([Z] ([Z] @c1.&mkdiagonal).map({.reverse.&report-visable.reverse}))
                                                  .deepmap({.defined ?? $_ !! |()});


        multi mkdiagonal(@a, Bool:D :$anti) { @a.reverse
                                          .map({[|(Nil xx $++), |$_, |(Nil xx (+@a - $++))]})
                                          .reverse }
        multi mkdiagonal(@a) { @a.map({[|(Nil xx $++), |$_, |(Nil xx (+@a - $++))]})} 

        sub report-visable($_) { .map({ .defined ?? +?(occupied ^ff empty) !! Nil })}
        note '↑\←:';
        @see:<↑\←>.deepmap({ when !.defined { "     "}; $_}).join("\n").say;
        say '↓\→:';
        @see:<↓\→>.deepmap({ when !.defined { "     "}; $_}).join("\n").say;
        note "↓/←:";
        @see:<↓/←>.deepmap({ when !.defined { "     "}; $_}).join("\n").say;
        note "total:";
        ([Z«+»] (@see:<↑/→>, @see:<↓/←>, @see:<↑\←>,@see:<↓\→>,
                 @see-to-bot, @see-to-left, @see-to-right, @see-to-top)).join("\n").say;
        note "↑/→:";
        @see:<↑/→>.deepmap({ when !.defined { "     "}; $_}).join("\n").say;
        note "to bot";
        @see-to-bot.join("\n").say;
        note "to top:";
        @see-to-top.join("\n").say;
        note "to rgt";
        @see-to-right.join("\n").say;
        note "to left";
        @see-to-left.join("\n").say;
}, 'part 2';
}

sub render(@a) { @a.deepmap({ when :2<00> { '.' }
                              when :2<01> { '#' }
                              when :2<10> { 'L' }})».join.join("\n") ~ "\n"}


